[{"title":"初次认识hexo","url":"/2021/05/18/hello-world/","content":"Quick Start初次编写博客~~主题选用: hexo-theme-Kaze\nCreate a new post（写作）$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server（本地运行）$ hexo server\n\nMore info: Server\nGenerate static files（打包）$ hexo generate\n\nMore info: Generating\nDeploy to remote sites（上传、部署）$ hexo deploy\n\nMore info: Deployment\n","categories":["个人"],"tags":["个人"]},{"title":"多页面配置","url":"/2019/04/02/vue-cli-multiPage/","content":"vue-cli如何搭建多页面项目地址\n\n如何使用本项目？ 本项目建立多页面步骤为：\n\n建立一个iflow页面&gt; 1 html/下新建文件 iflow.html&gt; 2 src/下新建文件夹及内容 iflow/                           /app/App.vue                            /routes/router.vue &gt; 3 entry/新建文件 iflow.js\n\n搭建脚手架 本地先安装vue脚手架\nnpm install vue-cli\n 选取webpack模版（这里我们使用的是webpack模版） 需要注意的是项目的名称不能大写，不然会报错。\nvue init webpack Name(取项目名)\n 选项翻译\nProject name (my-project) # 项目名称（我的项目）Project description (A Vue.js project) # 项目描述一个Vue.js 项目Author 作者（你的名字）Install vue-router? (Y/n) # 是否安装Vue路由，也就是以后是spa（但页面应用需要的模块）Use ESLint to lint your code? (Y/n) # 使用 ESLint 到你的代码？ （Y [ yes ] / N [ no ]）Pick an ESLint preset (Use arrow keys) # 选择一个预置ESLint（使用箭头键）Setup unit tests with Karma + Mocha? (Y/n) # 设置单元测Karma + Mocha？ （Y/ N）Setup e2e tests with Nightwatch? (Y/n) # 设置端到端测试，Nightwatch？ （Y/ N）\n\n\n 进去该项目\ncd Name\n 安装依赖\nnpm install\n\n 运行\nnpm run dev\n\n然后访问http://localhost:8080 //默认端口为8080，访问失败可以是端口被占用了，在config/index.js里改dev:{port}，换一个端口尝试\n\n多页面原理介绍 下面开始为脚手架配置多页面原理，此次搭建的是写死的配置，后面会添加动态方法\n 效果图：\n 多页面配置分dev环境跟prod环境\n\n我把html部分都放到了./html里面，把入口文件都放到了./src/entry/这个文件夹下面，方便统一管理，现在我们先安装好脚手架\n\n 首先是公共配置打开webpack.base.conf.js，找到entry，添加多入口\n//多页面入口,文件开始路径为项目初始路径entry: &#123;    mse: &#x27;./src/entry/mse.js&#x27;,    from: &#x27;./src/entry/from.js&#x27;,    common: &#x27;./src/entry/common.js&#x27;,&#125;,\n 运行、编译的时候每一个入口都会对应一个Chunk\n dev环境部署\n 修改 webpack.dev.conf.js\n\n打开 ~\\build\\webpack.dev.conf.js ，在plugins下找到new HtmlWebpackPlugin，在其后面添加对应的多页，并为每个页面添加Chunk配置\n\nnew HtmlWebpackPlugin(&#123;  filename: &#x27;mse.html&#x27;,//访问地址  template: &#x27;./html/mse.html&#x27;,//来源路径  inject: true,//是否开启注入  chunks: [&#x27;mse&#x27;]//入口文件，在base里的入口参数entry配置，需要引入的Chunk，不配置就会引入所有页面的资源&#125;),new HtmlWebpackPlugin(&#123;    filename: &#x27;from.html&#x27;,    template: &#x27;./html/from.html&#x27;,    inject: true,    chunks: [&#x27;from&#x27;]  &#125;),  new HtmlWebpackPlugin(&#123;    filename: &#x27;common.html&#x27;,    template: &#x27;./html/common.html&#x27;,    inject: true,    chunks: [&#x27;common&#x27;]  &#125;),\n\nchunks: [‘mse’]中的mse对应的是webpack.base.conf.js中entry设置的入口文件\n\n 修改完了以后再根据此项目目录结构对应修改，重新npm run dev 下，然后出入对应html即可出现\n prod环境部署\n 打开~\\config\\index.js，找到build下的index: path.resolve(__dirname, ‘../dist/index.html’)，在其后添加多页\nbuild: &#123;    mse: path.resolve(__dirname, &#x27;../dist/mse.html&#x27;),    from: path.resolve(__dirname, &#x27;../dist/from.html&#x27;),    common: path.resolve(__dirname, &#x27;../dist/common.html&#x27;),...&#125;\n\n 修改 webpack.prod.conf.js\n\n打开~\\build\\webpack.prod.conf.js，在plugins下找到new HtmlWebpackPlugin，在其后面添加对应的多页，并为每个页面添加Chunk配置\nHtmlWebpackPlugin 中的 filename 引用的是 config/index.js 中对应的 build\n\nplugins: [    new HtmlWebpackPlugin(&#123;        filename: config.build.mse,//入口文件        template: &#x27;./html/mse.html&#x27;,//来源路径        inject: true,        minify: &#123;            removeComments: true,            collapseWhitespace: true,            removeAttributeQuotes: true        &#125;,        chunksSortMode: &#x27;dependency&#x27;,        chunks: [&#x27;manifest&#x27;,&#x27;vendor&#x27;,&#x27;mse&#x27;]//需要引入的Chunk，不配置就会引入所有页面的资源    &#125;),    new HtmlWebpackPlugin(&#123;        filename: config.build.from,        template: &#x27;./html/from.html&#x27;,        inject: true,        minify: &#123;            removeComments: true,            collapseWhitespace: true,            removeAttributeQuotes: true        &#125;,        chunksSortMode: &#x27;dependency&#x27;,        chunks: [&#x27;manifest&#x27;,&#x27;vendor&#x27;,&#x27;from&#x27;]    &#125;),    new HtmlWebpackPlugin(&#123;        filename: config.build.common,        template: &#x27;./html/common.html&#x27;,        inject: true,        minify: &#123;            removeComments: true,            collapseWhitespace: true,            removeAttributeQuotes: true        &#125;,        chunksSortMode: &#x27;dependency&#x27;,        chunks: [&#x27;manifest&#x27;,&#x27;vendor&#x27;,&#x27;common&#x27;]    &#125;),]\n 这样，生产环境配置就修改完了，是不是没想象中这么麻烦呢，哈哈。现在打包npm run build 。如果出错了请检查自己的修改的是不是哪里写错了。一般是没问题的，本人亲测有效。打包好之后就丢进服务器里，访问即可看到效果啦！！！\n\n这是基于脚手架之多页面搭建的原理，都是用死方法写的，下次更新我会把他动态出来。到时候配置好，你就不用管其他，只需要添加文件夹，入口文件即可。\n\n\n\n\n如何设置动态多页面？ 首先我们需要用到几个插件\n\n我们现在utils.js文件引入跟加入我们需要的插件和文件// utils.js// 引入页面模版const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)// 用于做相应的merge处理const merge = require(&#x27;webpack-merge&#x27;)// 取得/src/entry下的所有入口文件var PAGE_PATH = path.resolve(__dirname, &#x27;../src/entry&#x27;)// 取得/html下的所有html文件var PAGE_HTML_PATH = path.resolve(__dirname, &#x27;../html&#x27;)\n\n 然后我们在utils.js里面添加两个动态获取入口/页面的方法\n\n定义entries方法动态在webpack.base.conf.js里动态设置多页面入口\n//动态设置多页面入口exports.entries = function() &#123;    var entryFiles = glob.sync(PAGE_PATH + &#x27;/*.js&#x27;)//获取当前路径下所有.js的文件    var map = &#123;&#125;    entryFiles.forEach((filePath) =&gt; &#123;        var filename = filePath.substring(filePath.lastIndexOf(&#x27;\\/&#x27;) + 1, filePath.lastIndexOf(&#x27;.&#x27;))        map[filename] = filePath    &#125;)    return map&#125;\n详情查看源代码\n//多页面入口,文件开始路径为项目初始路径//   entry: &#123;//     mse: &#x27;./src/entry/mse.js&#x27;,//     from: &#x27;./src/entry/from.js&#x27;,//     login: &#x27;./src/entry/login.js&#x27;,//   &#125;,\n//动态设置多页面入口entry: utils.entries(),\n\n定义htmlPlugin方法，用来获取html进行动态设置webpack\n//动态获取html文件 与上面的多页面入口配置相同，读取html文件夹下的对应的html后缀文件，然后放入数组中exports.htmlPlugin = function() &#123;    let entryHtml = glob.sync(PAGE_HTML_PATH + &#x27;/*.html&#x27;)    let arr = []    entryHtml.forEach((filePath) =&gt; &#123;        let filename = filePath.substring(filePath.lastIndexOf(&#x27;\\/&#x27;) + 1, filePath.lastIndexOf(&#x27;.&#x27;))        let conf = &#123;            // 文件名称            filename: filename + &#x27;.html&#x27;,            // 模板来源            template: filePath,            // 页面模板需要加对应的js脚本，如果不加这行则每个页面都会引入所有的js脚本            chunks: [&#x27;manifest&#x27;, &#x27;vendor&#x27;, filename],            inject: true        &#125;        if (process.env.NODE_ENV === &#x27;production&#x27;) &#123;//生产环境            conf = merge(conf, &#123;                //压缩HTML文件                minify: &#123;                    removeComments: true,                    collapseWhitespace: true,                    removeAttributeQuotes: true                &#125;,                //按照模块的依赖关系依次加载，即：manifest，vendor，本页面入口，其他页面入口.                chunksSortMode: &#x27;dependency&#x27;            &#125;)        &#125;        console.log(conf)        arr.push(new HtmlWebpackPlugin(conf))    &#125;)    return arr&#125;\n在webpack.dev.conf.js和webpack.prod.conf.js中都添加下面代码\n\n在plugins数组后面添加此方法\nplugins: [].concat(utils.htmlPlugin())\n这样就完成了动态设置，此时在config/index.js中注释掉下面代码就行了\nbuild: &#123;    // Template for index.html    // mse: path.resolve(__dirname, &#x27;../dist/mse.html&#x27;),    // from: path.resolve(__dirname, &#x27;../dist/from.html&#x27;),    // login: path.resolve(__dirname, &#x27;../dist/login.html&#x27;),    ...&#125;\n\n 这样的好处就是每个页面的router都是独立的，如果想只需要一个路由，那么应该在入口文件中都引入同一个路由就行了，理论上应该是这样，各位可以试试。\n 这样就可以了，如果不清楚哪里修改请查看源代码。\n添加了axios,以及本地代理功能 axios，是尤大大在vue2中推荐使用的请求方式，所以在这个项目中，我也加了此功能，用来请求数据\n 首先我们先安装axios\n//--save 发布后还需要依赖的模块//--save-dev 开发才用到它。npm install axios --save \n\n 然后我们在/config此文件夹下新建 http.js\n\n之所以在这里建立http.js，是想独立开这个axios这个功能，方便管理\n\n然后引入我们安装好的axios\nimport axios from &#x27;axios&#x27;;//引入axiosimport NProgress from &#x27;nprogress&#x27;; //引入进度条插件 ，npm install --save nprogressimport &#x27;nprogress/nprogress.css&#x27;; // 引入进度条css文件，相对路径即可//axios 基本配置axios.defaults.timeout = 50000;//请求超时时间axios.defaults.withCredentials = true;//运行跨域//设置头部信息axios.defaults.headers.common[&#x27;Cache-Control&#x27;] = &quot;no-cache&quot;;axios.defaults.headers.common[&#x27;Pragma&#x27;] = &quot;no-cache&quot;;\n然后我们在这个文件加上拦截器\n//添加一个请求拦截器axios.interceptors.request.use(function(config)&#123;    //在请求发出之前进行一些操作    NProgress.start();//进度条开始    return config;  &#125;,function(error)&#123;    NProgress.done();//进度条结束    //Do something with request error    return Promise.reject(error);&#125;);//添加一个响应拦截器  axios.interceptors.response.use(function(res)&#123;    //在这里对返回的数据进行处理    NProgress.done();    return res;  &#125;,function(error)&#123;    NProgress.done();    if (error.response) &#123;        switch (error.response.status) &#123;            case 401:                console.log(&#x27;接口返回401，请查看是否未登录。跳至登录页面&#x27;)        &#125;    &#125;    //Do something with response error    return Promise.reject(error);  &#125;)   export default axios;//最后我们要对axios导出去使用\n\n 现在我们已经对axios准备完毕了，然后我们就可以使用啦。。\n 这个时候就涉及到接口问题了，现在这个项目中有两个环境，本地环境跟生产环境，而接口在本地会出现跨域问题，我们先要解决跨域问题 我们在config/index.js这里配置代理\ndev&#123;    //设置代理    proxyTable: &#123;        &#x27;/operation/&#x27;:&#123;//将这个应用名下的请求转接为http://apiv2.pinduoduo.com下            target: &#x27;http://apiv2.pinduoduo.com/&#x27;,            secure: false        &#125;,        //如果多个不同的接口那就再加就行了，例如        &lt;!-- &#x27;/api/&#x27;:&#123;            target: &#x27;http:baidu.com/&#x27;,            secure: false        &#125;... --&gt;    &#125;,&#125;\n\n这样本地代理就完成了，那生产环境呢，这个一般我们打包好了项目丢到服务器中不会出现跨域问题，如果有的话让后端设置对应的处理就行了,所以我们在生产环境中基本不需要管跨域的问题.\n\n 不过我们需要区分开本地环境跟生产环境的域名，所以这时候我们还需要在config/下的额dev.env.js跟prod.env.js中设置对应的域名\n\n拿拼多多接口为例，在这两个文件中我们添加多一个字段，用来区分不同环境对应不同域名// dev.env.jsAPI_pingDuo:&quot;/operation/&quot;,//因为配置了代理，所以本地只需要配应用名就行了//prod.env.jsAPI_pingDuo:&#x27;&quot;http://apiv2.pinduoduo.com/operation/&quot;&#x27;,//生成环境需要放到对应服务器方可请求，否则报错。\n现在我们的环境问题也已经解决了，接下来我们就开始准备使用请求接口啦。。。\n\n 我们在src/下新建api目录，在里面再新建api.js跟main.js\n\napi.js是用来专门放api用的\nmain.js 是专门用来放请求用的，网上很多都是说把axios挂在vue的原型中，在组件中使用，这样个人觉得不方便管理，我们应该把每个功能点独立开来，这样方便我们后期的维护\n\n在api.js,在网上找到一个拼多多接口，不需要token校验，所以在本项目中拿来使用。\n//专门定义apiexport const pingDuo = process.env.API_pingDuo + &#x27;1284/groups?&#x27;;\n在main.js中写各种接口\nimport * as api from &#x27;./api&#x27;; //引入我们的所有接口import axios from &#x27;../../config/http&#x27;;//引入我们加了拦截的axiosimport qs from &#x27;querystring&#x27;;// 这个是下载axios自动安装的，我们直接使用即可，他是用来为我们处理接口数据的export const requestpingDuo = params =&gt; &#123;    return axios.get(api.pingDuo+qs.stringify(params)).then(res =&gt; res.data);&#125;;\n 这样我们的接口就写好啦，现在就开始使用咯\n\n我在mse.html里面进行演示在src/mse/app/App.vue里面我们加入对应的按钮&lt;template&gt;&lt;button @click=&quot;btnClick2&quot;&gt;点我请求数据拼多多&lt;/button&gt;&lt;ul v-for=&quot;(item,index) in pinDuoList&quot;&gt;    &lt;li&gt;&#123;&#123;item.goods_name&#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;/template&gt;&lt;script&gt;    methods:&#123;        //定义点击按钮事件，发送请求        btnClick2()&#123;            let params=&#123;                opt_type:1,                offset:0,                size:50            &#125;            requestpingDuo(params).then(res=&gt;&#123;                if(res)&#123;                    this.pinDuoList=res.goods_list;                &#125;            &#125;)        &#125;,    &#125;&lt;/script&gt;\n\n 效果图\n\n\n这样就实现了请求接口啦，下一次更新会上如何规避打包时不需要打包的页面\n\n过滤不需要打包的模块\n场景：很多时候我们在打包时候很多模块是不需要重复打包的，所以我们应该添加这个功能\n\n 首先我们先定义不需要打包的模块在build/build.js中定义，我们拿login这个模块来做实验\nprocess.env.filterSystem = [&quot;login&quot;]//过滤不打包模块\n 然后我们在我们的公共方法里面修改下配置在utils.js里面修改入口文件方法\n//动态设置多页面入口exports.entries = function() &#123;    var entryFiles = glob.sync(PAGE_PATH + &#x27;/*.js&#x27;)//获取当前路径下所有.js的文件    var map = &#123;&#125;    entryFiles.forEach((filePath) =&gt; &#123;        var filename = filePath.substring(filePath.lastIndexOf(&#x27;\\/&#x27;) + 1, filePath.lastIndexOf(&#x27;.&#x27;))        if(process.env.NODE_ENV === &#x27;production&#x27;)&#123;//生产环境过滤不打包系统            //判断设置的入口模块名不在filterSystem这里才进行追加            if (process.env.filterSystem.indexOf(filename) &lt; 0) &#123;                map[filename] = filePath            &#125;else&#123;                map[filename] = filePath            &#125;        &#125;    &#125;)    return map&#125;\n然后我们在获取html中也进行一些修改，\n//动态获取html文件 与上面的多页面入口配置相同，读取html文件夹下的对应的html后缀文件，然后放入数组中exports.htmlPlugin = function() &#123;    let entryHtml = glob.sync(PAGE_HTML_PATH + &#x27;/*.html&#x27;)    let arr = []    entryHtml.forEach((filePath) =&gt; &#123;        let filename = filePath.substring(filePath.lastIndexOf(&#x27;\\/&#x27;) + 1, filePath.lastIndexOf(&#x27;.&#x27;))        let conf = &#123;            // 文件名称            filename: filename + &#x27;.html&#x27;,            // 模板来源            template: filePath,            // 页面模板需要加对应的js脚本，如果不加这行则每个页面都会引入所有的js脚本            chunks: [&#x27;manifest&#x27;, &#x27;vendor&#x27;, filename],            inject: true        &#125;        if (process.env.NODE_ENV === &#x27;production&#x27;) &#123;//生产环境            //找到里面存在对应的模块，使其跳过即可            if (process.env.filterSystem.indexOf(filename) &gt;= 0) &#123;//过滤不需要打包系统                return ;            &#125;            conf = merge(conf, &#123;                //压缩HTML文件                minify: &#123;                    removeComments: true,                    collapseWhitespace: true,                    removeAttributeQuotes: true                &#125;,                //按照模块的依赖关系依次加载，即：manifest，vendor，本页面入口，其他页面入口.                chunksSortMode: &#x27;dependency&#x27;            &#125;)        &#125;        console.log(conf)        arr.push(new HtmlWebpackPlugin(conf))    &#125;)    return arr&#125;\n\n然后我们删除dist/这个文件夹下面的文件，重新打包 npm run build打包完成以后你会发现没有login.html了，在static中也没有对应的css跟js了这样就实现了我们打包时过滤不需要打包的模块了\n\n","categories":["多页面"],"tags":["vue","多页面"]}]